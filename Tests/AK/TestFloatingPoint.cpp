/*
 * Copyright (c) 2022, Jelle Raaijmakers <jelle@gmta.nl>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <AK/FloatingPoint.h>
#include <LibTest/TestCase.h>
#include <math.h>

TEST_CASE(f16_1_5_10_to_native_float)
{
    auto within_approximate = [](u16 lhs, float rhs) -> bool {
        auto f32_lhs = convert_to_native_float(FloatingPointBits<1, 5, 10>(lhs));
        return fabsf(f32_lhs - rhs) <= 0.00001f;
    };

    EXPECT(within_approximate(0x0000, 0.f));
    EXPECT(within_approximate(0x03FF, 0.000061f));
    EXPECT(within_approximate(0x3CEF, 1.23339f));
    EXPECT(within_approximate(0xBC00, -1.f));
    EXPECT(within_approximate(0xA266, -0.0125f));

    float result;
    result = convert_to_native_float(FloatingPointBits<1, 5, 10>(0xFC01u));
    EXPECT(isnan(result));

    result = convert_to_native_float(FloatingPointBits<1, 5, 10>(0x7C00u));
    EXPECT(isinf(result));
}

TEST_CASE(float_to_double_roundtrips)
{
    auto roundtrip = [](float floatvalue1) {
        auto doublevalue = convert_from_native_float<DoubleFloatingPointBits>(floatvalue1).as_double();
        auto floatbits = convert_from_native_double<SingleFloatingPointBits>(doublevalue);
        auto floatvalue2 = convert_to_native_float(floatbits);

        EXPECT_APPROXIMATE(floatvalue1, floatvalue2);
    };

    roundtrip(-1.0f);
    roundtrip(-0.1f);
    roundtrip(0.0f);
    roundtrip(0.000001f);
    roundtrip(0.1f);
    roundtrip(1.0f);
    roundtrip(3.141592f);
    roundtrip(16777216.0f);
    roundtrip(33554432.0f);

    roundtrip(1 / 0.0f);
    roundtrip(1 / -0.0f);
    roundtrip(0 / 0.0f);
}

TEST_CASE(normalize_denormalize)
{
    // Go from denormalized float to normalized double
    auto denormalized_float = 6.709679e-39f;
    auto denormalized_float_bits = SingleFloatingPointBits(denormalized_float);
    auto normalized_double = convert_to_native_double(denormalized_float_bits);
    EXPECT_APPROXIMATE(denormalized_float, normalized_double);

    // Go back from normalized double to denormalized float
    auto normalized_double_bits = DoubleFloatingPointBits(normalized_double);
    auto reconstructed_denormalized_float = convert_to_native_float(normalized_double_bits);
    EXPECT_APPROXIMATE(denormalized_float, reconstructed_denormalized_float);
}

TEST_CASE(large_exponent)
{
    // Make sure we support at least 62 bits of exponent
    auto large_exponent_float = convert_from_native_double<FloatingPointBits<1, 62, 1>>(1.0);
    auto converted_double = convert_to_native_double(large_exponent_float);
    EXPECT_APPROXIMATE(converted_double, 1.0);
}

TEST_CASE(large_mantissa)
{
    // Make sure we support at least 62 bits of mantissa
    auto large_exponent_float = convert_from_native_double<FloatingPointBits<1, 1, 62>>(1.0);
    auto converted_double = convert_to_native_double(large_exponent_float);
    EXPECT_APPROXIMATE(converted_double, 1.0);
}

enum class ApproximationKind {
    Cordic5,
    Cordic10,
    BKM30,
    BKM20,
    BKM10,
    Horner3,
    Horner4,
    Horner5,
    Taylor3,
    Taylor4,
    // TaylorBen,
    CubicBen,
    Sun,
};

template<FloatingPoint T>
constexpr T NaN = __builtin_nan("");
template<FloatingPoint T>
constexpr T Infinity = __builtin_huge_vall();

template<size_t N>
static double cordic_log2(double a)
{
    double x = a + 1;
    double y = a - 1;
    double z = 0;
    for (auto i = 1u; i < N + 1; ++i) {
        double sigma = y >= 0 ? -1 : 1;
        double new_x = x + sigma * pow(2., -i) * y;
        double new_y = y + sigma * pow(2., -i) * x;
        double new_z = z - sigma * atanh(pow(2., -i));
        x = new_x;
        y = new_y;
        z = new_z;
        // hyperbolic cordic does not converge, unless we repeat some iterations
        if (i % 3 == 1 && i != 1) {
            sigma = y >= 0 ? -1 : 1;
            new_x = x + sigma * pow(2, -i) * y;
            new_y = y + sigma * pow(2, -i) * x;
            new_z = z - sigma * atanh(pow(2, -i));
            x = new_x;
            y = new_y;
            z = new_z;
        }
    }
    // z requires no scaling factor
    return 2 * z;
}
constexpr double A_2[] = { // A_2[k] = log2(1 + pow(0.5, k))
    1.0000000000000000000000000000000000000000000000000000000000000000000000000000,
    0.5849625007211561814537389439478165087598144076924810604557526545410982276485,
    0.3219280948873623478703194294893901758648313930245806120547563958159347765589,
    0.1699250014423123629074778878956330175196288153849621209115053090821964552970,
    0.0874628412503394082540660108104043540112672823448206881266090643866965081686,
    0.0443941193584534376531019906736094674630459333742491317685543002674288465967,
    0.0223678130284545082671320837460849094932677948156179815932199216587899627785,
    0.0112272554232541203378805844158839407281095943600297940811823651462712311786,
    0.0056245491938781069198591026740666017211096815383520359072957784732489771013,
    0.0028150156070540381547362547502839489729507927389771959487826944878598909400,
    0.0014081943928083889066101665016890524233311715793462235597709051792834906001,
    0.0007042690112466432585379340422201964456668872087249334581924550139514213168,
    0.0003521774803010272377989609925281744988670304302127133979341729842842377649,
    0.0001760994864425060348637509459678580940163670081839283659942864068257522373,
    0.0000880524301221769086378699983597183301490534085738474534831071719854721939,
    0.0000440268868273167176441087067175806394819146645511899503059774914593663365,
    0.0000220136113603404964890728830697555571275493801909791504158295359319433723,
    0.0000110068476674814423006223021573490183469930819844945565597452748333526464,
    0.0000055034343306486037230640321058826431606183125807276574241540303833251704,
    0.0000027517197895612831123023958331509538486493412831626219340570294203116559,
    0.0000013758605508411382010566802834037147561973553922354232704569052932922954,
    0.0000006879304394358496786728937442939160483304056131990916985043387874690617,
    0.0000003439652607217645360118314743718005315334062644619363447395987584138324,
    0.0000001719826406118446361936972479533123619972434705828085978955697643547921,
    0.0000000859913228686632156462565208266682841603921494181830811515318381744650,
    0.0000000429956620750168703982940244684787907148132725669106053076409624949917,
    0.0000000214978311976797556164155504126645192380395989504741781512309853438587,
    0.0000000107489156388827085092095702361647949603617203979413516082280717515504,
    0.0000000053744578294520620044408178949217773318785601260677517784797554422804,
    0.0000000026872289172287079490026152352638891824761667284401180026908031182361,
    0.0000000013436144592400232123622589569799954658536700992739887706412976115422,
    0.0000000006718072297764289157920422846078078155859484240808550018085324187007,
    0.0000000003359036149273187853169587152657145221968468364663464125722491530858,
    0.0000000001679518074734354745159899223037458278711244127245990591908996412262,
    0.0000000000839759037391617577226571237484864917411614198675604731728132152582,
    0.0000000000419879518701918839775296677020135040214077417929807824842667285938,
    0.0000000000209939759352486932678195559552767641474249812845414125580747434389,
    0.0000000000104969879676625344536740142096218372850561859495065136990936290929,
    0.0000000000052484939838408141817781356260462777942148580518406975851213868092,
    0.0000000000026242469919227938296243586262369156865545638305682553644113887909,
    0.0000000000013121234959619935994960031017850191710121890821178731821983105443,
    0.0000000000006560617479811459709189576337295395590603644549624717910616347038,
    0.0000000000003280308739906102782522178545328259781415615142931952662153623493,
    0.0000000000001640154369953144623242936888032768768777422997704541618141646683,
    0.0000000000000820077184976595619616930350508356401599552034612281802599177300,
    0.0000000000000410038592488303636807330652208397742314215159774270270147020117,
    0.0000000000000205019296244153275153381695384157073687186580546938331088730952,
    0.0000000000000102509648122077001764119940017243502120046885379813510430378661,
    0.0000000000000051254824061038591928917243090559919209628584150482483994782302,
    0.0000000000000025627412030519318726172939815845367496027046030028595094737777,
    0.0000000000000012813706015259665053515049475574143952543145124550608158430592,
    0.0000000000000006406853007629833949364669629701200556369782295210193569318434,
    0.0000000000000003203426503814917330334121037829290364330169106716787999052925,
    0.0000000000000001601713251907458754080007074659337446341494733882570243497196,
    0.0000000000000000800856625953729399268240176265844257044861248416330071223615,
    0.0000000000000000400428312976864705191179247866966320469710511619971334577509,
    0.0000000000000000200214156488432353984854413866994246781519154793320684126179,
    0.0000000000000000100107078244216177339743404416874899847406043033792202127070,
    0.0000000000000000050053539122108088756700751579281894640362199287591340285355,
    0.0000000000000000025026769561054044400057638132352058574658089256646014899499,
    0.0000000000000000012513384780527022205455634651853807110362316427807660551208,
    0.0000000000000000006256692390263511104084521222346348012116229213309001913762,
    0.0000000000000000003128346195131755552381436585278035120438976487697544916191,
    0.0000000000000000001564173097565877776275512286165232838833090480508502328437,
    0.0000000000000000000782086548782938888158954641464170239072244145219054734086,
    0.0000000000000000000391043274391469444084776945327473574450334092075712154016,
    0.0000000000000000000195521637195734722043713378812583900953755962557525252782,
    0.0000000000000000000097760818597867361022187915943503728909029699365320287407,
    0.0000000000000000000048880409298933680511176764606054809062553340323879609794,
    0.0000000000000000000024440204649466840255609083961603140683286362962192177597,
    0.0000000000000000000012220102324733420127809717395445504379645613448652614939,
    0.0000000000000000000006110051162366710063906152551383735699323415812152114058,
    0.0000000000000000000003055025581183355031953399739107113727036860315024588989,
    0.0000000000000000000001527512790591677515976780735407368332862218276873443537,
    0.0000000000000000000000763756395295838757988410584167137033767056170417508383,
    0.0000000000000000000000381878197647919378994210346199431733717514843471513618,
    0.0000000000000000000000190939098823959689497106436628681671067254111334889005,
    0.0000000000000000000000095469549411979844748553534196582286585751228071408728,
    0.0000000000000000000000047734774705989922374276846068851506055906657137209047,
    0.0000000000000000000000023867387352994961187138442777065843718711089344045782,
    0.0000000000000000000000011933693676497480593569226324192944532044984865894525,
    0.0000000000000000000000005966846838248740296784614396011477934194852481410926,
    0.0000000000000000000000002983423419124370148392307506484490384140516252814304,
    0.0000000000000000000000001491711709562185074196153830361933046331030629430117,
    0.0000000000000000000000000745855854781092537098076934460888486730708440475045,
    0.0000000000000000000000000372927927390546268549038472050424734256652501673274,
    0.0000000000000000000000000186463963695273134274519237230207489851150821191330,
    0.0000000000000000000000000093231981847636567137259618916352525606281553180093,
    0.0000000000000000000000000046615990923818283568629809533488457973317312233323,
    0.0000000000000000000000000023307995461909141784314904785572277779202790023236,
    0.0000000000000000000000000011653997730954570892157452397493151087737428485431,
    0.0000000000000000000000000005826998865477285446078726199923328593402722606924,
    0.0000000000000000000000000002913499432738642723039363100255852559084863397344,
    0.0000000000000000000000000001456749716369321361519681550201473345138307215067,
    0.0000000000000000000000000000728374858184660680759840775119123438968122488047,
    0.0000000000000000000000000000364187429092330340379920387564158411083803465567,
    0.0000000000000000000000000000182093714546165170189960193783228378441837282509,
    0.0000000000000000000000000000091046857273082585094980096891901482445902524441,
    0.0000000000000000000000000000045523428636541292547490048446022564529197237262,
    0.0000000000000000000000000000022761714318270646273745024223029238091160103901
};

template<size_t bits>
static double bkm_log2(double a)
{
    double x = 1.0;
    double y = 0.0;
    double s = 1.0;

    for (auto k = 0u; k < bits; k++) {
        double const z = x + x * s;
        if (z <= a) {
            x = z;
            y += A_2[k];
        }
        s *= 0.5;
    }
    return y;
}

template<ApproximationKind kind>
static double log2_impl([[maybe_unused]] double a)
{
    VERIFY_NOT_REACHED();
}

template<>
double log2_impl<ApproximationKind::Cordic10>(double a)
{
    return cordic_log2<10>(a) / 0.6931471805599453 /*ln(2)*/ + 1;
}

template<>
double log2_impl<ApproximationKind::Cordic5>(double a)
{
    return cordic_log2<5>(a) / 0.6931471805599453 /*ln(2)*/ + 1;
}

template<>
double log2_impl<ApproximationKind::Horner5>(double a)
{
    return a * (a * (((double)0.688101329132870 - (double)0.0873431279665709 * a) * a - (double)2.23432594978817) + (double)4.19641546493297) - (double)2.56284771631110;
}

template<>
double log2_impl<ApproximationKind::Horner4>(double a)
{
    return a * (a * (a * (0.569953 - 0.0712442 * a) - 1.92359) + 3.84718) - 2.42065;
}

template<>
double log2_impl<ApproximationKind::Horner3>(double a)
{
    return a * (a * ((0.688101329132870 - 0.0873431279665709 * a) * a - 2.23432594978817) + 4.19641546493297) - 2.56284771631110;
}

template<>
double log2_impl<ApproximationKind::CubicBen>(double a)
{
    return ((0.1640425613334453 * a - 1.098865286222745) * a + 3.1482979293341167) * a - 2.2134752044448174;
}

template<>
double log2_impl<ApproximationKind::Taylor4>(double a)
{
    return 0.584963
        + 0.961797 * (a - 1.5)
        - 0.320599 * (a - 1.5) * (a - 1.5)
        + 0.142488 * (a - 1.5) * (a - 1.5) * (a - 1.5)
        - 0.0712442 * (a - 1.5) * (a - 1.5) * (a - 1.5) * (a - 1.5);
}

template<>
double log2_impl<ApproximationKind::Taylor3>(double a)
{
    return -2.56284771631110
        + 4.19641546493297 * a
        - 2.23432594978817 * a * a
        + 0.688101329132870 * a * a * a
        - 0.0873431279665709 * a * a * a * a;
}

template<>
double log2_impl<ApproximationKind::BKM30>(double a)
{
    return bkm_log2<30>(a);
}

template<>
double log2_impl<ApproximationKind::BKM20>(double a)
{
    return bkm_log2<20>(a);
}

template<>
double log2_impl<ApproximationKind::BKM10>(double a)
{
    return bkm_log2<10>(a);
}

template<>
double log2_impl<ApproximationKind::Sun>(double a)
{
    auto s = (a - 1) / (a + 1);
    auto xsq = s * s;
    auto ln_approx = xsq * (0.6666666666666735130 + xsq * (0.3999999999940941908 + xsq * (0.2857142874366239149 + xsq * (0.2222219843214978396 + xsq * (0.1818357216161805012 + xsq * (0.1531383769920937332 + xsq * (0.1479819860511658591)))))));
    auto log_approx = (2 * s + s * ln_approx) * 1.4426950408889634;
    return log_approx;
}

template<ApproximationKind kind>
static double log2(double x)
{
    if (x == 0)
        return -Infinity<double>;
    if (x <= 0 || __builtin_isnan(x))
        return NaN<double>;

    FloatExtractor<double> ext { .d = x };
    double exponent = ext.exponent - FloatExtractor<double>::exponent_bias;

    // When the mantissa shows 0b00 (implicitly 1.0) we are on a power of 2
    if (ext.mantissa == 0)
        return exponent;

    FloatExtractor<double> mantissa_ext {
        {
            ext.mantissa,
            FloatExtractor<double>::exponent_bias,
            ext.sign,
        },
    };

    // (1 <= mantissa < 2)
    double mantissa = mantissa_ext.d;

    double log2_mantissa = log2_impl<kind>(mantissa);

    return exponent + log2_mantissa;
}

template<ApproximationKind kind>
static double benchmark_log()
{
    double result = 1;
    for (auto i = 0u; i < 1000000; ++i) {
        double x = i / 100.0;
        result /= log2<kind>(x);
    }
    return result;
}

BENCHMARK_CASE(cordic5_log)
{
    EXPECT(benchmark_log<ApproximationKind::Cordic5>() != 0.0);
}
BENCHMARK_CASE(cordic10_log)
{
    EXPECT(benchmark_log<ApproximationKind::Cordic10>() != 0.0);
}
BENCHMARK_CASE(horner5_log)
{
    EXPECT(benchmark_log<ApproximationKind::Horner5>() != 0.0);
}
BENCHMARK_CASE(horner4_log)
{
    EXPECT(benchmark_log<ApproximationKind::Horner4>() != 0.0);
}
BENCHMARK_CASE(horner3_log)
{
    EXPECT(benchmark_log<ApproximationKind::Horner3>() != 0.0);
}
BENCHMARK_CASE(Taylor4_log)
{
    EXPECT(benchmark_log<ApproximationKind::Taylor4>() != 0.0);
}
BENCHMARK_CASE(Taylor3_log)
{
    EXPECT(benchmark_log<ApproximationKind::Taylor3>() != 0.0);
}
BENCHMARK_CASE(CubicBen_log)
{
    EXPECT(benchmark_log<ApproximationKind::CubicBen>() != 0.0);
}
BENCHMARK_CASE(BKM30_log)
{
    EXPECT(benchmark_log<ApproximationKind::BKM30>() != 0.0);
}
BENCHMARK_CASE(BKM20_log)
{
    EXPECT(benchmark_log<ApproximationKind::BKM20>() != 0.0);
}
BENCHMARK_CASE(BKM10_log)
{
    EXPECT(benchmark_log<ApproximationKind::BKM10>() != 0.0);
}
BENCHMARK_CASE(Sun_log)
{
    EXPECT(benchmark_log<ApproximationKind::Sun>() != 0.0);
}
